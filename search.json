[{"path":"https://przechoj.github.io/gips/articles/Introduction.html","id":"the-problem","dir":"Articles","previous_headings":"","what":"The problem","title":"Introduction","text":"Quite often, little data perform valid inference. Consider situation multivariate Gaussian distribution, observations compared number variables. ’s case graphical models used biology medicine. setting, usual way finding covariance matrix (maximum likelihood method) isn’t statistically applicable. now?","code":""},{"path":"https://przechoj.github.io/gips/articles/Introduction.html","id":"invariance-by-permutation","dir":"Articles","previous_headings":"","what":"Invariance by permutation","title":"Introduction","text":"Quite often, variables can used interchangeably. multivariate Gaussian case mean, variances covariances respective variables. instance, following matrix variables X1 X3 interchangeable:  Now, can state interchangeability property terms permutations. case, swapping first third row, swapping first third column, results matrix. words, matrix invariant permutation (1->3, 3->1). cyclic form (1,3). course, samples collected real world perfect equalities observed. Still, respective values (poorly) estimated covariance matrix close , adopting certain assumption invariance permutation reasonable step.","code":""},{"path":"https://przechoj.github.io/gips/articles/Introduction.html","id":"package-gips","dir":"Articles","previous_headings":"","what":"Package gips","title":"Introduction","text":"propose create set constraints covariance matrix , maximum likelihood method can used . constraint consider - none - invariance permutation symmetry. package provides way find reasonable permutation used constraint covariance matrix estimation. case reasonable means , maximizes Bayesian posterior distribution using Wishart disribution symmetric, positive definite matrices prior. idea, exact formulas algorithm sketch contribution PAPER.","code":""},{"path":"https://przechoj.github.io/gips/articles/Introduction.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Introduction","text":"","code":"library(gips)"},{"path":"https://przechoj.github.io/gips/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Przemyslaw Chojecki. Author, maintainer. Pawel Morgen. Author. Bartosz Kolodziejek. Author.","code":""},{"path":"https://przechoj.github.io/gips/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Chojecki P, Morgen P, Kolodziejek B (2022). gips: Gaussian Model Invariant Permutation Symmetry. https://github.com/PrzeChoj/gips, https://przechoj.github.io/gips/.","code":"@Manual{,   title = {gips: Gaussian Model Invariant by Permutation Symmetry},   author = {Przemyslaw Chojecki and Pawel Morgen and Bartosz Kolodziejek},   year = {2022},   note = {https://github.com/PrzeChoj/gips, https://przechoj.github.io/gips/}, }"},{"path":"https://przechoj.github.io/gips/index.html","id":"gips","dir":"","previous_headings":"","what":"Gaussian Model Invariant by Permutation Symmetry","title":"Gaussian Model Invariant by Permutation Symmetry","text":"gips - Gaussian model Invariant Permutation Symmetry gips R package finds permutation symmetry group covariance matrix given data invariant . Knowledge permutation can drastically decrease number parameters needed fit model. means gips, possible find Gaussian model parameters number observations. Sometimes, even number observations bigger number parameters, covariance matrix found gips better approximates actual covariance behind data.","code":""},{"path":"https://przechoj.github.io/gips/index.html","id":"gips-will-help-you-with-two-things","dir":"","previous_headings":"","what":"gips will help you with two things:","title":"Gaussian Model Invariant by Permutation Symmetry","text":"Exploratory Data Analysis (EDA) - gips, can find permutation features approximately change covariance matrix. Modeling - gips, can accurately use found permutation fit normal models like LDA QDA.","code":""},{"path":"https://przechoj.github.io/gips/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Gaussian Model Invariant by Permutation Symmetry","text":"can install development version gips GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"PrzeChoj/gips\")"},{"path":[]},{"path":"https://przechoj.github.io/gips/index.html","id":"example-1---eda","dir":"","previous_headings":"Examples","what":"Example 1 - EDA","title":"Gaussian Model Invariant by Permutation Symmetry","text":"Assume data, want understand structure:","code":"library(gips)  Z <- as.matrix(mtcars)  # Assume the data is normal.   # Looking at this (`hist(Z[,2])`) distribution,   # it is not a remarkably sensible assumption,   # but let's do it for the example.  S <- cor(Z) g <- gips(S, nrow(Z), was_mean_estimated = TRUE) plot(g, type = 'heatmap') # We can see some strong relationships between columns in this matrix.   # For example, 9 and 10 have very similar correlations to other variables.  # Let's see if the find_MAP will find this relationship: g_MAP <- find_MAP(g, max_iter = 10, optimizer = \"MH\") #> ======================================================================== plot(g_MAP, type = 'heatmap') # Even after a short time (only 10 iterations),   # find_MAP found some relationship.  # Let's see what it will find with a slightly bigger budget: g_MAP <- find_MAP(g_MAP, max_iter = 100, optimizer = \"continue\") #> =============================================================================== plot(g_MAP, type = 'heatmap') # find_MAP found the (9,10) relationship and even something more."},{"path":"https://przechoj.github.io/gips/index.html","id":"example-2---modeling","dir":"","previous_headings":"Examples","what":"Example 2 - modeling","title":"Gaussian Model Invariant by Permutation Symmetry","text":"Assume know mean 0, want estimate covariance matrix, don’t enough data:","code":"# Prepare model, multivariate normal distribution perm_size <- 6 mu <- numeric(perm_size)   sigma_matrix <- matrix(   data = c(     1.0, 0.8, 0.6, 0.4, 0.6, 0.8,     0.8, 1.0, 0.8, 0.6, 0.4, 0.6,     0.6, 0.8, 1.0, 0.8, 0.6, 0.4,     0.4, 0.6, 0.8, 1.0, 0.8, 0.6,     0.6, 0.4, 0.6, 0.8, 1.0, 0.8,     0.8, 0.6, 0.4, 0.6, 0.8, 1.0   ),   nrow = perm_size, byrow = TRUE ) # sigma_matrix is a matrix invariant under permutation (1,2,3,4,5,6)  # generate example data from a model: Z <- MASS::mvrnorm(4, mu = mu, Sigma = sigma_matrix) # End of prepare model    library(gips) (number_of_observations <- nrow(Z)) # 4 < 6, so n < p #> [1] 4  # calculate the covariance matrix from the data: S <- (t(Z) %*% Z) / number_of_observations  # Make the gips object out of data: g <- gips(S, number_of_observations, was_mean_estimated = FALSE)  # Find the Maximum A Posteriori Estimator for the permutation.   # Space is small (6! = 720), so it is reasonable to   # browse the whole of it: g_map <- find_MAP(g, show_progress_bar = TRUE, optimizer = \"full\") #> ================================================================================ g_map #> The permutation (1,2,3,4,5,6) was found after 720 log_posteriori calculations, is 2509.07979453551 times more likely than the starting,  permutation.  summary(g_map)$n0 #> [1] 1 summary(g_map)$n0 <= 4 #> [1] TRUE  # We see the number of observations (4) is bigger or equal to n0,   # so we can estimate the covariance matrix   # with the Maximum Likelihood estimator: project_matrix(S, g_map[[1]]) #>          [,1]     [,2]     [,3]     [,4]     [,5]     [,6] #> [1,] 2.502065 2.270992 2.051661 1.820588 2.051661 2.270992 #> [2,] 2.270992 2.502065 2.270992 2.051661 1.820588 2.051661 #> [3,] 2.051661 2.270992 2.502065 2.270992 2.051661 1.820588 #> [4,] 1.820588 2.051661 2.270992 2.502065 2.270992 2.051661 #> [5,] 2.051661 1.820588 2.051661 2.270992 2.502065 2.270992 #> [6,] 2.270992 2.051661 1.820588 2.051661 2.270992 2.502065  # Plot the found matrix: plot(g_map, type = \"heatmap\")"},{"path":"https://przechoj.github.io/gips/index.html","id":"credits","dir":"","previous_headings":"","what":"Credits","title":"Gaussian Model Invariant by Permutation Symmetry","text":"gips developed 2022 Przemysław Chojecki Paweł Morgen leadership Ph.D. Bartosz Kołodziejek within “CyberiADa-3” (2021) grant Warsaw University Technology.","code":""},{"path":"https://przechoj.github.io/gips/reference/G_function.html","id":null,"dir":"Reference","previous_headings":"","what":"G_function for log_posteriori_of_gips() — G_function","title":"G_function for log_posteriori_of_gips() — G_function","text":"G_function log_posteriori_of_gips()","code":""},{"path":"https://przechoj.github.io/gips/reference/G_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"G_function for log_posteriori_of_gips() — G_function","text":"","code":"G_function(structure_constants, delta = 3)"},{"path":"https://przechoj.github.io/gips/reference/G_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"G_function for log_posteriori_of_gips() — G_function","text":"structure_constants Constants get_structure_constants function. delta Parameter method.","code":""},{"path":"https://przechoj.github.io/gips/reference/G_function.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"G_function for log_posteriori_of_gips() — G_function","text":"Sum logarithms elements calculate_gamma_omega L. log product part equation (27). information, see Issue #3 gips' GitHub.","code":""},{"path":"https://przechoj.github.io/gips/reference/G_function.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"G_function for log_posteriori_of_gips() — G_function","text":"","code":"perm_size <- 6 perm <- permutations::as.cycle(permutations::as.word(c(2, 3, 1, 5, 4, 6))) gips_perm <- gips_perm(perm, perm_size) structure_constants <- get_structure_constants(gips_perm) gips:::G_function(structure_constants, 3) #> [1] 2.799934"},{"path":"https://przechoj.github.io/gips/reference/as.character.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform gips_perm object to character vector — as.character.gips_perm","title":"Transform gips_perm object to character vector — as.character.gips_perm","text":"Implementation S3 method.","code":""},{"path":"https://przechoj.github.io/gips/reference/as.character.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform gips_perm object to character vector — as.character.gips_perm","text":"","code":"# S3 method for gips_perm as.character(x, ...)"},{"path":"https://przechoj.github.io/gips/reference/as.character.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform gips_perm object to character vector — as.character.gips_perm","text":"x object gips_perm class. ... arguments passed permutations::.character.cycle().","code":""},{"path":"https://przechoj.github.io/gips/reference/as.character.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform gips_perm object to character vector — as.character.gips_perm","text":"Returns object character type.","code":""},{"path":"https://przechoj.github.io/gips/reference/as.character.html","id":"methods-by-class-","dir":"Reference","previous_headings":"","what":"Methods (by class)","title":"Transform gips_perm object to character vector — as.character.gips_perm","text":".character(gips_perm):","code":""},{"path":[]},{"path":"https://przechoj.github.io/gips/reference/as.character.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform gips_perm object to character vector — as.character.gips_perm","text":"","code":"g_perm <- gips_perm(permutations::as.cycle(\"(5,4)\"), 5) as.character(g_perm) #> [1] \"(4,5)\""},{"path":"https://przechoj.github.io/gips/reference/calculate_gamma_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Gamma function — calculate_gamma_function","title":"Calculate Gamma function — calculate_gamma_function","text":"calculates value integral defined Definition 11 references. implementation Theorem 8 references using formula (19) references.","code":""},{"path":"https://przechoj.github.io/gips/reference/calculate_gamma_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Gamma function — calculate_gamma_function","text":"","code":"calculate_gamma_function(perm, lambda)"},{"path":"https://przechoj.github.io/gips/reference/calculate_gamma_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Gamma function — calculate_gamma_function","text":"perm object gips_perm class. lambda positive real number.","code":""},{"path":"https://przechoj.github.io/gips/reference/calculate_gamma_function.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Gamma function — calculate_gamma_function","text":"Returns value Gamma function.","code":""},{"path":"https://przechoj.github.io/gips/reference/calculate_gamma_function.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate Gamma function — calculate_gamma_function","text":"Piotr Graczyk, Hideyuki Ishi, Bartosz Kolodziejek, Hélène Massam. \"Model selection space Gaussian models invariant symmetry.\" Annals Statistics, 50(3) 1747-1774 June 2022. DOI: 10.1214/22-AOS2174","code":""},{"path":[]},{"path":"https://przechoj.github.io/gips/reference/calculate_gamma_function.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Gamma function — calculate_gamma_function","text":"","code":"id_perm <- gips_perm(permutations::id, 2) calculate_gamma_function(id_perm, 0.5001) # 10.7... #> [1] 10.70139 calculate_gamma_function(id_perm, 0.50000001) # 19.9... #> [1] 19.91198 calculate_gamma_function(id_perm, 0.500000000001) # 29.1... #> [1] 29.12235 # calculate_gamma_function(id_perm, 0.5) # integral diverges; returns Inf and warning"},{"path":"https://przechoj.github.io/gips/reference/calculate_gamma_omega.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate logarithm of a single Gamma omega function — calculate_gamma_omega","title":"Calculate logarithm of a single Gamma omega function — calculate_gamma_omega","text":"Using formula (12) paper","code":""},{"path":"https://przechoj.github.io/gips/reference/calculate_gamma_omega.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate logarithm of a single Gamma omega function — calculate_gamma_omega","text":"","code":"calculate_gamma_omega(lambda, dim_omega_i, r_i, d_i)"},{"path":"https://przechoj.github.io/gips/reference/calculate_gamma_omega.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate logarithm of a single Gamma omega function — calculate_gamma_omega","text":"lambda positive real number. dim_omega_i Single element get_structure_constants. r_i Single element get_structure_constants. d_i Single element get_structure_constants.","code":""},{"path":"https://przechoj.github.io/gips/reference/calculate_gamma_omega.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate logarithm of a single Gamma omega function — calculate_gamma_omega","text":"Logarithm value Gamma function.","code":""},{"path":"https://przechoj.github.io/gips/reference/find_MAP.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the Maximum A Posteriori Estimation — find_MAP","title":"Find the Maximum A Posteriori Estimation — find_MAP","text":"Use one optimization algorithms find permutation maximizes posteriori based observed data. optimization algorithms always find MAP, try find significant value. information can found 'Possible algorithms use optimizers' section .","code":""},{"path":"https://przechoj.github.io/gips/reference/find_MAP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the Maximum A Posteriori Estimation — find_MAP","text":"","code":"find_MAP(   g,   max_iter = NA,   optimizer = NA,   show_progress_bar = TRUE,   return_probabilities = FALSE )"},{"path":"https://przechoj.github.io/gips/reference/find_MAP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the Maximum A Posteriori Estimation — find_MAP","text":"g Object gips class max_iter Number iterations algorithm perform. least 2. optimizer==\"MH\" finite; optimizer==\"HC\" can infinite; optimizer==\"BF\" used. optimizer optimizer search maximum posteriori. \"MH\" (default unoptimized g) - Metropolis-Hastings \"HC\" - Hill Climbing \"BF\" - Brute Force \"continue\" (default optimized g) - g optimized (see Examples). details, see \"Possible algorithms use optimizers\" section . show_progress_bar boolean. Indicate whether show progress bar. max_iter infinite, show_progress_bar FALSE. return_probabilities boolean. TRUE can provided : optimizer==\"MH\" - use Metropolis-Hastings results estimate posterior probabilities optimizer==\"BF\" - use brute force results calculate exact posterior probabilities","code":""},{"path":"https://przechoj.github.io/gips/reference/find_MAP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the Maximum A Posteriori Estimation — find_MAP","text":"Returns optimized object gips class.","code":""},{"path":"https://przechoj.github.io/gips/reference/find_MAP.html","id":"possible-algorithms-to-use-as-optimizers","dir":"Reference","previous_headings":"","what":"Possible algorithms to use as optimizers","title":"Find the Maximum A Posteriori Estimation — find_MAP","text":"\"Metropolis_Hastings\", \"MH\" - use Metropolis-Hastings algorithm; see Wikipedia. algorithm draw random transposition every iteration consider changing current one. max_iter reached, algorithm return MAP Estimator best permutation calculated far. \"hill_climbing\", \"HC\" - use hill climbing algorithm; see Wikipedia. algorithm check transpositions every iteration go one biggest posteriori value. optimization ends neighbors smaller posteriori value. max_iter reached end, warning shown, recommended start optimization output find_MAP(). Remember p*(p-1)/2 transpositions checked every iteration. bigger p, may costly. \"brute_force\", \"BF\", \"full\" - use Brute Force algorithm checks whole permutation space given size. algorithm definitely find Maximum Posteriori Estimation computationally expensive bigger space.","code":""},{"path":[]},{"path":"https://przechoj.github.io/gips/reference/find_MAP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find the Maximum A Posteriori Estimation — find_MAP","text":"","code":"require(\"MASS\") # for mvrnorm() #> Loading required package: MASS  perm_size <- 6 mu <- runif(6, -10, 10) # Assume we don't know the mean sigma_matrix <- matrix(   data = c(     1.0, 0.8, 0.6, 0.4, 0.6, 0.8,     0.8, 1.0, 0.8, 0.6, 0.4, 0.6,     0.6, 0.8, 1.0, 0.8, 0.6, 0.4,     0.4, 0.6, 0.8, 1.0, 0.8, 0.6,     0.6, 0.4, 0.6, 0.8, 1.0, 0.8,     0.8, 0.6, 0.4, 0.6, 0.8, 1.0   ),   nrow = perm_size, byrow = TRUE ) # sigma_matrix is a matrix invariant under permutation (1,2,3,4,5,6) number_of_observations <- 13 Z <- MASS::mvrnorm(number_of_observations, mu = mu, Sigma = sigma_matrix) S <- cov(Z) # Assume we have to estimate the mean  g <- gips(S, number_of_observations)  g_map <- find_MAP(g, max_iter = 10, show_progress_bar = FALSE, optimizer = \"MH\") g_map #> The permutation (3,6)(4,5) was found after 10 log_posteriori calculations, is 38.8942692522271 times more likely than the starting, () permutation.  g_map2 <- find_MAP(g_map, max_iter = 10, show_progress_bar = FALSE, optimizer = \"continue\")  if (require(\"graphics\")) {   plot(g_map2, type = \"both\", logarithmic_x = TRUE) }   g_map_BF <- find_MAP(g, show_progress_bar = FALSE, optimizer = \"BF\") summary(g_map_BF) #> The optimized `gips` object. #>  #> Permutation: #>  (1,2,3,4,5,6) #>  #> Log_posteriori: #>  -8.119972 #>  #> Times more likely than starting permutation: #> 6181.31336313793 #>  #> Number of observations: #>  13 #>  #> The mean in `S` matrix was estimated. #> Therefore, one degree of freedom was lost. #> There is 12 degrees of freedom left. #>  #> n0: #>  2 #>  #> Number of observations is bigger than n0 for this permutaion, #> so the gips model based on the found permutation does exist. #>  #> -------------------------------------------------------------------------------- #> Optimization algorithm: #>  brute_force #>  #> Number of log_posteriori calls: #>  720 #>  #> Optimization time: #>  1.438144 secs"},{"path":"https://przechoj.github.io/gips/reference/get_structure_constants.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Structure Constants — get_structure_constants","title":"Get Structure Constants — get_structure_constants","text":"Constants useful internal calculations integrals eventually posteriori probability log_posteriori_of_gips().","code":""},{"path":"https://przechoj.github.io/gips/reference/get_structure_constants.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Structure Constants — get_structure_constants","text":"","code":"get_structure_constants(perm)"},{"path":"https://przechoj.github.io/gips/reference/get_structure_constants.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Structure Constants — get_structure_constants","text":"perm object gips_perm class.","code":""},{"path":"https://przechoj.github.io/gips/reference/get_structure_constants.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Structure Constants — get_structure_constants","text":"Returns list 5 items: r, d, k, L, dim_omega - vectors constants Theorem 1 references beginning section 3.1. references.","code":""},{"path":"https://przechoj.github.io/gips/reference/get_structure_constants.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get Structure Constants — get_structure_constants","text":"Uses Theorem 5 references calculate constants.","code":""},{"path":"https://przechoj.github.io/gips/reference/get_structure_constants.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Get Structure Constants — get_structure_constants","text":"Piotr Graczyk, Hideyuki Ishi, Bartosz Kolodziejek, Hélène Massam. \"Model selection space Gaussian models invariant symmetry.\" Annals Statistics, 50(3) 1747-1774 June 2022. DOI: 10.1214/22-AOS2174","code":""},{"path":[]},{"path":"https://przechoj.github.io/gips/reference/get_structure_constants.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Structure Constants — get_structure_constants","text":"","code":"perm <- gips_perm(permutations::as.word(c(1, 2, 3, 5, 4)), 5) get_structure_constants(perm) #> $r #> [1] 4 1 #>  #> $d #> [1] 1 1 #>  #> $k #> [1] 1 1 #>  #> $L #> [1] 2 #>  #> $dim_omega #> [1] 10  1 #>"},{"path":"https://przechoj.github.io/gips/reference/gips.html","id":null,"dir":"Reference","previous_headings":"","what":"The constructor of a gips class. — gips","title":"The constructor of a gips class. — gips","text":"Create gips object. object consist data information needed find likely invariant permutation. optimization performed. One must call find_MAP() function . See examples .","code":""},{"path":"https://przechoj.github.io/gips/reference/gips.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The constructor of a gips class. — gips","text":"","code":"gips(   S,   number_of_observations,   delta = 3,   D_matrix = NULL,   was_mean_estimated = TRUE,   perm = \"\" )  new_gips(   list_of_gips_perm,   S,   number_of_observations,   delta,   D_matrix,   was_mean_estimated,   optimization_info )  validate_gips(g)"},{"path":"https://przechoj.github.io/gips/reference/gips.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The constructor of a gips class. — gips","text":"S matrix; estimated covariance matrix. Z observed data: one know theoretical mean estimate observed mean, use S = cov(Z), set parameter was_mean_estimated = FALSE. one know theoretical mean 0, use S = (t(Z) %*% Z) / number_of_observations, set parameter was_mean_estimated = FALSE; number_of_observations number data points S based . delta hyper-parameter Bayesian model. bigger 2. D_matrix hyper-parameter Bayesian model. Square matrix size S. NULL, identity matrix taken. was_mean_estimated logical (TRUE FALSE). Set TRUE (default) S parameter result stats::cov() function. Set FALSE S parameter result (t(Z) %*% Z) / number_of_observations calculation. perm optional permutation base gips object. Can gips_perm permutation class, anything function permutations::permutation() can handle. list_of_gips_perm list single element gips_perm class. base object gips object. optimization_info NULL list information optimization process. g Element checked proper element gips class.","code":""},{"path":"https://przechoj.github.io/gips/reference/gips.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The constructor of a gips class. — gips","text":"gips() returns object gips class safety checks. new_gips() returns object gips class without safety checks. validate_gips() returns argument unchanged. argument correct element gips class, produces error.","code":""},{"path":"https://przechoj.github.io/gips/reference/gips.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"The constructor of a gips class. — gips","text":"new_gips(): Constructor. intended low-level use. validate_gips(): Validator. intended low-level use.","code":""},{"path":"https://przechoj.github.io/gips/reference/gips.html","id":"methods-for-a-gips-class","dir":"Reference","previous_headings":"","what":"Methods for a gips class","title":"The constructor of a gips class. — gips","text":"summary.gips() plot.gips() print.gips()","code":""},{"path":[]},{"path":"https://przechoj.github.io/gips/reference/gips.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The constructor of a gips class. — gips","text":"","code":"require(\"MASS\") # for mvrnorm()  perm_size <- 6 mu <- runif(6, -10, 10) # Assume we don't know the mean sigma_matrix <- matrix(   data = c(     1.0, 0.8, 0.6, 0.4, 0.6, 0.8,     0.8, 1.0, 0.8, 0.6, 0.4, 0.6,     0.6, 0.8, 1.0, 0.8, 0.6, 0.4,     0.4, 0.6, 0.8, 1.0, 0.8, 0.6,     0.6, 0.4, 0.6, 0.8, 1.0, 0.8,     0.8, 0.6, 0.4, 0.6, 0.8, 1.0   ),   nrow = perm_size, byrow = TRUE ) # sigma_matrix is a matrix invariant under permutation (1,2,3,4,5,6) number_of_observations <- 13 Z <- MASS::mvrnorm(number_of_observations, mu = mu, Sigma = sigma_matrix) S <- cov(Z) # Assume we have to estimate the mean  g <- gips(S, number_of_observations)  g_map <- find_MAP(g, max_iter = 10, show_progress_bar = FALSE, optimizer = \"MH\") g_map #> The permutation (1,4) was found after 10 log_posteriori calculations, is 1.81710697540621 times more likely than the starting, () permutation.  summary(g_map) #> The optimized `gips` object. #>  #> Permutation: #>  (1,4) #>  #> Log_posteriori: #>  -13.91306 #>  #> Times more likely than starting permutation: #> 1.81710697540621 #>  #> Number of observations: #>  13 #>  #> The mean in `S` matrix was estimated. #> Therefore, one degree of freedom was lost. #> There is 12 degrees of freedom left. #>  #> n0: #>  6 #>  #> Number of observations is bigger than n0 for this permutaion, #> so the gips model based on the found permutation does exist. #>  #> -------------------------------------------------------------------------------- #> Optimization algorithm: #>  Metropolis_Hastings #>  #> Number of log_posteriori calls: #>  10 #>  #> Optimization time: #>  0.01719904 secs #>  #> Acceptance rate: #>  0.1 #>  #> Log_posteriori calls after the found permutation: #>  0  if (require(\"graphics\")) {   plot(g_map, type = \"both\", logarithmic_x = TRUE) }"},{"path":"https://przechoj.github.io/gips/reference/gips_perm.html","id":null,"dir":"Reference","previous_headings":"","what":"Permutation object — gips_perm","title":"Permutation object — gips_perm","text":"Create permutation objects passed functions gips package.","code":""},{"path":"https://przechoj.github.io/gips/reference/gips_perm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Permutation object — gips_perm","text":"","code":"gips_perm(x, size)  new_gips_perm(rearranged_cycles, size)  validate_gips_perm(g)"},{"path":"https://przechoj.github.io/gips/reference/gips_perm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Permutation object — gips_perm","text":"x object created permutations package object can processed permutations::permutation() function. size integer. Size permutation (AKA cardinality set, permutation defined). rearranged_cycles list rearranged integer vectors. vector corresponds single cycle permutation. g Element checked proper element gips_perm class.","code":""},{"path":"https://przechoj.github.io/gips/reference/gips_perm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Permutation object — gips_perm","text":"gips_perm() returns object gips_perm class safety checks. new_gips_perm() returns object gips_perm class without safety checks. validate_gips_perm() returns argument unchanged. argument correct element gips_perm class, produces error.","code":""},{"path":"https://przechoj.github.io/gips/reference/gips_perm.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Permutation object — gips_perm","text":"new_gips_perm(): Constructor. intended low-level use. validate_gips_perm(): Validator. intended low-level use.","code":""},{"path":"https://przechoj.github.io/gips/reference/gips_perm.html","id":"methods-for-a-gips-class","dir":"Reference","previous_headings":"","what":"Methods for a gips class","title":"Permutation object — gips_perm","text":".character.gips_perm() print.gips_perm()","code":""},{"path":[]},{"path":"https://przechoj.github.io/gips/reference/gips_perm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Permutation object — gips_perm","text":"","code":"gperm <- gips_perm(permutations::as.word(c(1, 2, 3, 5, 4)), 5) gperm <- gips_perm(permutations::as.cycle(\"(5,4)\"), 5) # note the necessity of `size` parameter gperm <- gips_perm(permutations::as.cycle(\"(5,4)\"), 7) gperm <- gips_perm(\"(1,2)(5,4)\", 7) gperm #> [1] (12)(45)  # gperm <- gips_perm(permutations::as.cycle(\"(5,4)\"), 3) # Error, `size` equals 3 while the maximum element is 5."},{"path":"https://przechoj.github.io/gips/reference/log_posteriori_of_gips.html","id":null,"dir":"Reference","previous_headings":"","what":"A log of a posteriori that the covariance matrix is invariant under permutation. — log_posteriori_of_gips","title":"A log of a posteriori that the covariance matrix is invariant under permutation. — log_posteriori_of_gips","text":"precisely, logarithm unnormalized posterior probability. goal function optimization algorithms find_MAP() function. perm_proposal maximizes function Maximum Posteriori (MAP) Estimator.","code":""},{"path":"https://przechoj.github.io/gips/reference/log_posteriori_of_gips.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A log of a posteriori that the covariance matrix is invariant under permutation. — log_posteriori_of_gips","text":"","code":"log_posteriori_of_gips(g)"},{"path":"https://przechoj.github.io/gips/reference/log_posteriori_of_gips.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A log of a posteriori that the covariance matrix is invariant under permutation. — log_posteriori_of_gips","text":"g object gips_perm class.","code":""},{"path":"https://przechoj.github.io/gips/reference/log_posteriori_of_gips.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A log of a posteriori that the covariance matrix is invariant under permutation. — log_posteriori_of_gips","text":"Returns value logarithm unnormalized Posteriori.","code":""},{"path":"https://przechoj.github.io/gips/reference/log_posteriori_of_gips.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A log of a posteriori that the covariance matrix is invariant under permutation. — log_posteriori_of_gips","text":"calculated using formulas (33) (27) references. Inf NaN reached, produces warning.","code":""},{"path":"https://przechoj.github.io/gips/reference/log_posteriori_of_gips.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"A log of a posteriori that the covariance matrix is invariant under permutation. — log_posteriori_of_gips","text":"Piotr Graczyk, Hideyuki Ishi, Bartosz Kolodziejek, Hélène Massam. \"Model selection space Gaussian models invariant symmetry.\" Annals Statistics, 50(3) 1747-1774 June 2022. DOI: 10.1214/22-AOS2174","code":""},{"path":[]},{"path":"https://przechoj.github.io/gips/reference/log_posteriori_of_gips.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A log of a posteriori that the covariance matrix is invariant under permutation. — log_posteriori_of_gips","text":"","code":"# In the space with p = 2, there is only 2 permutations: perm1 <- permutations::as.cycle(permutations::as.word(c(1, 2))) # (1)(2) perm2 <- permutations::as.cycle(permutations::as.word(c(2, 1))) # (1,2) S1 <- matrix(c(1, 0.5, 0.5, 2), nrow = 2, byrow = TRUE) g1 <- gips(S1, 100, perm = perm1) g2 <- gips(S1, 100, perm = perm2) log_posteriori_of_gips(g1) # -136.6, this is the MAP Estimator #> [1] -135.3433 log_posteriori_of_gips(g2) # -140.4 #> [1] -139.0036  exp(log_posteriori_of_gips(g1) - log_posteriori_of_gips(g2)) # 41.3 #> [1] 38.87122 # g1 is over 40 times more likely than g2. # This is the expected outcome because S[1,1] significantly differs from S[2,2].  # ========================================================================  S2 <- matrix(c(1, 0.5, 0.5, 1.1), nrow = 2, byrow = TRUE) g1 <- gips(S2, 100, perm = perm1) g2 <- gips(S2, 100, perm = perm2) log_posteriori_of_gips(g1) # -99.5 #> [1] -98.54173 log_posteriori_of_gips(g2) # -96.9, this is the MAP Estimator #> [1] -96.00429  exp(log_posteriori_of_gips(g2) - log_posteriori_of_gips(g1)) # 12.7 #> [1] 12.64729 # g2 is over 12 times more likely than g1. # This is the expected outcome because S[1,1] is very close to S[2,2]."},{"path":"https://przechoj.github.io/gips/reference/plot.gips.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot optimized matrix or optimization gips object — plot.gips","title":"Plot optimized matrix or optimization gips object — plot.gips","text":"Plot heatmap MAP covariance matrix estimator convergence optimization method. plot depends type argument.","code":""},{"path":"https://przechoj.github.io/gips/reference/plot.gips.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot optimized matrix or optimization gips object — plot.gips","text":"","code":"# S3 method for gips plot(   x,   type = NA,   logarithmic_y = TRUE,   logarithmic_x = FALSE,   color = NULL,   title_text = \"Convergence plot\",   xlabel = NULL,   ylabel = NULL,   show_legend = TRUE,   ylim = NULL,   xlim = NULL,   ... )"},{"path":"https://przechoj.github.io/gips/reference/plot.gips.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot optimized matrix or optimization gips object — plot.gips","text":"x Object gips class. type single character. One c(\"heatmap\", \"\", \"best\", \"\"). \"heatmap\" - Plots heatmap S matrix inside gips object projected permutation gips object. \"\" - Plots line posteriori visited states. \"best\" - Plots line biggest posteriori moment. \"\" - Plots lines \"\" \"best\". default value NA, changed \"heatmap\" non-optimized gips objects \"\" optimized ones. Using default produces warning. arguments ignored type = \"heatmap\". logarithmic_y, logarithmic_x boolean. Sets axis plot logarithmic scale. color Vector colors used plot lines. title_text Text title plot. xlabel Text bottom plot. ylabel Text left plot. show_legend boolean. Whether show legend. ylim Limits y axis. NULL, minimum maximum log_posteriori_of_gips() taken. xlim Limits x axis. NULL, whole optimization process shown. ... Additional arguments passed stats::heatmap() various elements plot.","code":""},{"path":"https://przechoj.github.io/gips/reference/plot.gips.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot optimized matrix or optimization gips object — plot.gips","text":"Returns invisible NULL.","code":""},{"path":[]},{"path":"https://przechoj.github.io/gips/reference/plot.gips.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot optimized matrix or optimization gips object — plot.gips","text":"","code":"require(\"MASS\") # for mvrnorm()  perm_size <- 6 mu <- runif(6, -10, 10) # Assume we don't know the mean sigma_matrix <- matrix(   data = c(     1.0, 0.8, 0.6, 0.4, 0.6, 0.8,     0.8, 1.0, 0.8, 0.6, 0.4, 0.6,     0.6, 0.8, 1.0, 0.8, 0.6, 0.4,     0.4, 0.6, 0.8, 1.0, 0.8, 0.6,     0.6, 0.4, 0.6, 0.8, 1.0, 0.8,     0.8, 0.6, 0.4, 0.6, 0.8, 1.0   ),   nrow = perm_size, byrow = TRUE ) # sigma_matrix is a matrix invariant under permutation (1,2,3,4,5,6) number_of_observations <- 13 Z <- MASS::mvrnorm(number_of_observations, mu = mu, Sigma = sigma_matrix) S <- cov(Z) # Assume we have to estimate the mean  g <- gips(S, number_of_observations) if (require(\"graphics\")) {   plot(g, type = \"heatmap\") }   g_map <- find_MAP(g, max_iter = 30, show_progress_bar = FALSE, optimizer = \"HC\") if (require(\"graphics\")) {   plot(g_map, type = \"both\", logarithmic_x = TRUE) }   if (require(\"graphics\")) {   plot(g_map, type = \"heatmap\") } # Now, the output is (most likely) different because the permutation      # `g_map[[1]]` is (most likely) not an identity permutation."},{"path":"https://przechoj.github.io/gips/reference/prepare_orthogonal_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare orthogonal matrix — prepare_orthogonal_matrix","title":"Prepare orthogonal matrix — prepare_orthogonal_matrix","text":"Calculate orthogonal matrix U_Gamma decomposition Theorem 1 references.","code":""},{"path":"https://przechoj.github.io/gips/reference/prepare_orthogonal_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare orthogonal matrix — prepare_orthogonal_matrix","text":"","code":"prepare_orthogonal_matrix(perm, perm_size = NULL, basis = NULL)"},{"path":"https://przechoj.github.io/gips/reference/prepare_orthogonal_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare orthogonal matrix — prepare_orthogonal_matrix","text":"perm Object gips_perm permutations::cycle class. perm_size Size permutation. Required perm permutations::cycle class. basis matrix basis vectors COLUMNS. Identity default.","code":""},{"path":"https://przechoj.github.io/gips/reference/prepare_orthogonal_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare orthogonal matrix — prepare_orthogonal_matrix","text":"matrix perm_size x perm_size columns V object elements, sorted according Theorem 6.","code":""},{"path":"https://przechoj.github.io/gips/reference/prepare_orthogonal_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prepare orthogonal matrix — prepare_orthogonal_matrix","text":"Given X - invariant permutation perm. Call Gamma permutations cyclic group \\(<perm> = {perm, perm^2, ...}\\). , U_Gamma orthogonal matrix X \"pretty\" . precise, matrix t(U_Gamma) %*% X %*% U_Gamma lot zeros (see examples). calculate , Theorem 6 references used.","code":""},{"path":"https://przechoj.github.io/gips/reference/prepare_orthogonal_matrix.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Prepare orthogonal matrix — prepare_orthogonal_matrix","text":"Piotr Graczyk, Hideyuki Ishi, Bartosz Kolodziejek, Hélène Massam. \"Model selection space Gaussian models invariant symmetry.\" Annals Statistics, 50(3) 1747-1774 June 2022. DOI: 10.1214/22-AOS2174","code":""},{"path":[]},{"path":"https://przechoj.github.io/gips/reference/prepare_orthogonal_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare orthogonal matrix — prepare_orthogonal_matrix","text":"","code":"gperm <- gips_perm(\"(1,2,3)(4,5)\", 5) U_g <- prepare_orthogonal_matrix(gperm)  number_of_observations <- 10 X <- matrix(rnorm(5 * number_of_observations), number_of_observations, 5) S <- cov(X) X <- project_matrix(S, perm = gperm) # this matrix in invariant under gperm  t(U_g) %*% X %*% U_g # the non-zeros only on diagonal and [1,2] and [2,1] #>               [,1]          [,2]          [,3]          [,4]      [,5] #> [1,]  5.364222e-01 -7.503583e-02 -5.551115e-17  5.551115e-17 0.0000000 #> [2,] -7.503583e-02  7.386332e-01  1.040834e-17 -1.040834e-17 0.0000000 #> [3,] -5.551115e-17  9.813078e-18  1.161636e+00  2.775558e-16 0.0000000 #> [4,]  5.551115e-17 -9.813078e-18  3.330669e-16  1.161636e+00 0.0000000 #> [5,]  0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00 0.8533729"},{"path":"https://przechoj.github.io/gips/reference/print.gips.html","id":null,"dir":"Reference","previous_headings":"","what":"Printing gips object — print.gips","title":"Printing gips object — print.gips","text":"Printing function gips class.","code":""},{"path":"https://przechoj.github.io/gips/reference/print.gips.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Printing gips object — print.gips","text":"","code":"# S3 method for gips print(x, digits = Inf, compare_to_original = TRUE, log_value = FALSE, ...)"},{"path":"https://przechoj.github.io/gips/reference/print.gips.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Printing gips object — print.gips","text":"x object gips class. digits number digits comma posteriori presented. can negative. default, Inf. passed base::round(). compare_to_original logical. Whether print many times likely current permutation compared : identity permutation () (unoptimized gips object); starting permutation (optimized gips object). log_value logical. Whether print value log_posteriori_of_gips(). Default FALSE. ... additional arguments passed base::cat().","code":""},{"path":"https://przechoj.github.io/gips/reference/print.gips.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Printing gips object — print.gips","text":"Returns invisible NULL.","code":""},{"path":[]},{"path":"https://przechoj.github.io/gips/reference/print.gips.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Printing gips object — print.gips","text":"","code":"S <- matrix(c(1, 0.5, 0.5, 2), nrow = 2, byrow = TRUE) g <- gips(S, 10) # print(g, digits = 4)"},{"path":"https://przechoj.github.io/gips/reference/print.gips_perm.html","id":null,"dir":"Reference","previous_headings":"","what":"Printing gips_perm object — print.gips_perm","title":"Printing gips_perm object — print.gips_perm","text":"Printing function gips_perm class.","code":""},{"path":"https://przechoj.github.io/gips/reference/print.gips_perm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Printing gips_perm object — print.gips_perm","text":"","code":"# S3 method for gips_perm print(x, ...)"},{"path":"https://przechoj.github.io/gips/reference/print.gips_perm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Printing gips_perm object — print.gips_perm","text":"x object gips_perm class. ... arguments passed permutations::print.cycle().","code":""},{"path":"https://przechoj.github.io/gips/reference/print.gips_perm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Printing gips_perm object — print.gips_perm","text":"Returns argument invisibly, printing .","code":""},{"path":"https://przechoj.github.io/gips/reference/print.gips_perm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Printing gips_perm object — print.gips_perm","text":"","code":"g_perm <- gips_perm(permutations::as.cycle(\"(5,4)\"), 5) # print(g_perm)"},{"path":"https://przechoj.github.io/gips/reference/project_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Project matrix — project_matrix","title":"Project matrix — project_matrix","text":"Project matrix space symmetrical matrices invariant cyclic group permutations.","code":""},{"path":"https://przechoj.github.io/gips/reference/project_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project matrix — project_matrix","text":"","code":"project_matrix(S, perm, precomputed_equal_indices = NULL)"},{"path":"https://przechoj.github.io/gips/reference/project_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project matrix — project_matrix","text":"S square matrix projected. perm permutation. Generator permutation group. Either gips_perm permutations::cycle class. precomputed_equal_indices parameter used internal calculations equal indices already calculated. case, leave parameter NULL, computed.","code":""},{"path":"https://przechoj.github.io/gips/reference/project_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project matrix — project_matrix","text":"projected matrix.","code":""},{"path":"https://przechoj.github.io/gips/reference/project_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Project matrix — project_matrix","text":"S sample covariance matrix (output cov(X) function, see examples), S unbiased estimator covariance matrix. However, maximum likelihood estimator covariance matrix S*(n-1)/(n), unless p > n, maximum likelihood estimator exist. information, see Wikipedia - Estimation covariance matrices. maximum likelihood estimator differs one knows covariance matrix invariant permutation. estimator symmetric also values (see examples). estimator invariant given permutation. Also, need fewer observations maximum likelihood estimator exist (see summary.gips()). permutations, even n = 1 enough.","code":""},{"path":[]},{"path":"https://przechoj.github.io/gips/reference/project_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Project matrix — project_matrix","text":"","code":"p <- 6 gperm <- gips_perm(permutations::as.word(c(4, 3, 2, 1, 5)), p) # permutation (1,4)(2,3)(5)(6)  number_of_observations <- 10 X <- matrix(rnorm(p * number_of_observations), number_of_observations, p) S <- cov(X) projected_S <- project_matrix(S, perm = gperm) projected_S #>            [,1]       [,2]       [,3]       [,4]       [,5]       [,6] #> [1,]  0.6791607 -0.2649207 -0.0633885 -0.3334201 -0.1972591 -0.2699378 #> [2,] -0.2649207  1.1564354  0.4868264 -0.0633885 -0.1991072  0.3370801 #> [3,] -0.0633885  0.4868264  1.1564354 -0.2649207 -0.1991072  0.3370801 #> [4,] -0.3334201 -0.0633885 -0.2649207  0.6791607 -0.1972591 -0.2699378 #> [5,] -0.1972591 -0.1991072 -0.1991072 -0.1972591  1.3796181  0.1029336 #> [6,] -0.2699378  0.3370801  0.3370801 -0.2699378  0.1029336  0.9195197 # The value in [1,1] is the same as in [4,4]; also, [2,2] and [3,3];   # also [1,2] and [4,3]; also, [1,5] and [4,5]; and so on  # Plot the projected matrix: g <- gips(S, number_of_observations, perm = gperm) plot(g, type = \"heatmap\")   # Find the MAP Estimator g_MAP <- find_MAP(g, max_iter = 10, show_progress_bar = FALSE, optimizer = \"MH\") S_MAP <- project_matrix(S, perm = g_MAP[[1]]) S_MAP #>            [,1]      [,2]       [,3]       [,4]       [,5]       [,6] #> [1,]  1.0171314 0.1279800 -0.1767989 -0.1629264 -0.1629264 -0.1767989 #> [2,]  0.1279800 0.8846731  0.1279800  0.1279800  0.1279800  0.1279800 #> [3,] -0.1767989 0.1279800  1.0171314 -0.1767989 -0.1629264 -0.1629264 #> [4,] -0.1629264 0.1279800 -0.1767989  1.0171314 -0.1767989 -0.1629264 #> [5,] -0.1629264 0.1279800 -0.1629264 -0.1767989  1.0171314 -0.1767989 #> [6,] -0.1767989 0.1279800 -0.1629264 -0.1629264 -0.1767989  1.0171314 plot(g_MAP, type = \"heatmap\")"},{"path":"https://przechoj.github.io/gips/reference/runif_transposition.html","id":null,"dir":"Reference","previous_headings":"","what":"Uniformly random transposition of perm_size elements — runif_transposition","title":"Uniformly random transposition of perm_size elements — runif_transposition","text":"Uniformly random transposition perm_size elements","code":""},{"path":"https://przechoj.github.io/gips/reference/runif_transposition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Uniformly random transposition of perm_size elements — runif_transposition","text":"","code":"runif_transposition(perm_size)"},{"path":"https://przechoj.github.io/gips/reference/runif_transposition.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Uniformly random transposition of perm_size elements — runif_transposition","text":"perm_size size take transpositions.","code":""},{"path":"https://przechoj.github.io/gips/reference/summary.gips.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarizing the gips object — summary.gips","title":"Summarizing the gips object — summary.gips","text":"summary method class \"gips\".","code":""},{"path":"https://przechoj.github.io/gips/reference/summary.gips.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarizing the gips object — summary.gips","text":"","code":"# S3 method for gips summary(object, ...)  # S3 method for summary.gips print(x, ...)"},{"path":"https://przechoj.github.io/gips/reference/summary.gips.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarizing the gips object — summary.gips","text":"object object class \"gips\"; usually result find_MAP(). ... arguments passed methods. x object class \"summary.gips\" printed","code":""},{"path":"https://przechoj.github.io/gips/reference/summary.gips.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarizing the gips object — summary.gips","text":"function summary.gips computes returns list summary statistics given gips object. : unoptimized gips object: optimized - FALSE start_permutation - permutation gips represents start_permutation_log_posteriori - log posteriori value start permutation times_more_likely_than_id - many likely start_permutation identity permutation, (). can number less 1, means identity permutation, (), likely n0 - minimal number observations needed MAP Estimator covariance matrix exist S_matrix - underlying matrix; used calculate posteriori value number_of_observations - number observations observed S_matrix calculated; used calculate posteriori value was_mean_estimated - given user creating gips object: TRUE means S parameter output stats::cov() function FALSE means S parameter calculated S = t(X) %*% X / number_of_observations delta, D_matrix - parameters Bayesian method optimized gips object: optimized - TRUE found_permutation - permutation gips represents; visited permutation biggest posteriori value found_permutation_log_posteriori - log posteriori value found permutation start_permutation - original permutation gips represented optimization; first visited permutation start_permutation_log_posteriori - log posteriori value start permutation times_more_likely_than_start - many likely found_permutation start_permutation. number less 1 n0 - minimal number observations needed MAP Estimator covariance matrix exist S_matrix - underlying matrix; used calculate posteriori value number_of_observations - number observations observed S_matrix calculated; used calculate posteriori value was_mean_estimated - given user creating gips object: TRUE means S parameter output stats::cov() function FALSE means S parameter calculated S = t(X) %*% X / number_of_observations delta, D_matrix - parameters Bayesian method optimization_algorithm_used - used optimization algorithms order (one start optimization \"MH\", \"HC\") did_converge - boolean, last used algorithm converge number_of_log_posteriori_calls - many times log_posteriori_of_gips() function called optimization full_optimization_time - long optimization process; sum optimization times (multiple) log_posteriori_calls_after_best - many times log_posteriori_of_gips() function called found_permutation; words, long ago optimization stopped result; value small, consider running find_MAP() one time optimizer = \"continue\". optimizer = \"BF\", NULL acceptance_rate - interesting optimizer = \"MH\"; often algorithm accepting change permutation iteration print.summary.gips returns invisible NULL.","code":""},{"path":"https://przechoj.github.io/gips/reference/summary.gips.html","id":"methods-by-generic-","dir":"Reference","previous_headings":"","what":"Methods (by generic)","title":"Summarizing the gips object — summary.gips","text":"print(summary.gips): Printing method class \"summary.gips\". Prints every interesting information pleasant, human readable form","code":""},{"path":[]},{"path":"https://przechoj.github.io/gips/reference/summary.gips.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarizing the gips object — summary.gips","text":"","code":"require(\"MASS\") # for mvrnorm()  perm_size <- 6 mu <- runif(6, -10, 10) # Assume we don't know the mean sigma_matrix <- matrix(   data = c(     1.0, 0.8, 0.6, 0.4, 0.6, 0.8,     0.8, 1.0, 0.8, 0.6, 0.4, 0.6,     0.6, 0.8, 1.0, 0.8, 0.6, 0.4,     0.4, 0.6, 0.8, 1.0, 0.8, 0.6,     0.6, 0.4, 0.6, 0.8, 1.0, 0.8,     0.8, 0.6, 0.4, 0.6, 0.8, 1.0   ),   nrow = perm_size, byrow = TRUE ) # sigma_matrix is a matrix invariant under permutation (1,2,3,4,5,6) number_of_observations <- 13 Z <- MASS::mvrnorm(number_of_observations, mu = mu, Sigma = sigma_matrix) S <- cov(Z) # Assume we have to estimate the mean  g <- gips(S, number_of_observations)  g_map <- find_MAP(g, max_iter = 10, show_progress_bar = FALSE, optimizer = \"MH\") unclass(summary(g_map)) #> $optimized #> [1] TRUE #>  #> $found_permutation #> [1] (14) #>  #> $found_permutation_log_posteriori #> [1] -17.42718 #>  #> $start_permutation #> [1] () #>  #> $start_permutation_log_posteriori #> [1] -20.39495 #>  #> $times_more_likely_than_start #> [1] 19.44838 #>  #> $n0 #> [1] 6 #>  #> $S_matrix #>          [,1]     [,2]     [,3]     [,4]     [,5]     [,6] #> [1,] 1.173595 1.205934 1.262443 1.243334 1.210996 1.154486 #> [2,] 1.205934 1.715210 1.754166 1.598407 1.089130 1.050174 #> [3,] 1.262443 1.754166 2.060608 1.827343 1.335620 1.029178 #> [4,] 1.243334 1.598407 1.827343 2.045180 1.690107 1.461171 #> [5,] 1.210996 1.089130 1.335620 1.690107 1.811973 1.565483 #> [6,] 1.154486 1.050174 1.029178 1.461171 1.565483 1.586479 #>  #> $number_of_observations #> [1] 13 #>  #> $was_mean_estimated #> [1] TRUE #>  #> $delta #> [1] 3 #>  #> $D_matrix #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    1    0    0    0    0    0 #> [2,]    0    1    0    0    0    0 #> [3,]    0    0    1    0    0    0 #> [4,]    0    0    0    1    0    0 #> [5,]    0    0    0    0    1    0 #> [6,]    0    0    0    0    0    1 #>  #> $optimization_algorithm_used #> [1] \"Metropolis_Hastings\" #>  #> $did_converge #> NULL #>  #> $number_of_log_posteriori_calls #> [1] 10 #>  #> $full_optimization_time #> Time difference of 0.01603198 secs #>  #> $log_posteriori_calls_after_best #> [1] 0 #>  #> $acceptance_rate #> [1] 0.1 #>   g_map2 <- find_MAP(g, max_iter = 10, show_progress_bar = FALSE, optimizer = \"HC\") summary(g_map2) #> The optimized `gips` object. #>  #> Permutation: #>  (2,5)(3,6) #>  #> Log_posteriori: #>  -12.33937 #>  #> Times more likely than starting permutation: #> 3151.33086056097 #>  #> Number of observations: #>  13 #>  #> The mean in `S` matrix was estimated. #> Therefore, one degree of freedom was lost. #> There is 12 degrees of freedom left. #>  #> n0: #>  5 #>  #> Number of observations is bigger than n0 for this permutaion, #> so the gips model based on the found permutation does exist. #>  #> -------------------------------------------------------------------------------- #> Optimization algorithm: #>  hill_climbing did converge #>  #> Number of log_posteriori calls: #>  76 #>  #> Optimization time: #>  0.1120868 secs #>  #> Log_posteriori calls after the found permutation: #>  27 # ================================================================================ S <- matrix(c(1, 0.5, 0.5, 2), nrow = 2, byrow = TRUE) g <- gips(S, 10) # print(summary(g))"}]
